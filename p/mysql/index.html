<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="mysql-八股题，包含：基础、锁、索引、事务以及场景题"><title>Mysql-八股题</title>
<link rel=canonical href=https://www.yangdiy.cn/p/mysql/><link rel=stylesheet href=/scss/style.min.6e03ee55b17945eb2fa06f4a57afe9fdc11d2c74584b65390b797fd77f42b29c.css><meta property='og:title' content="Mysql-八股题"><meta property='og:description' content="mysql-八股题，包含：基础、锁、索引、事务以及场景题"><meta property='og:url' content='https://www.yangdiy.cn/p/mysql/'><meta property='og:site_name' content='米粒儿'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='数据库'><meta property='article:tag' content='Mysql'><meta property='article:published_time' content='2024-11-30T00:00:00+00:00'><meta property='article:modified_time' content='2025-01-10T18:05:42+08:00'><meta name=twitter:title content="Mysql-八股题"><meta name=twitter:description content="mysql-八股题，包含：基础、锁、索引、事务以及场景题"><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-LEVBX7WQQ0"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LEVBX7WQQ0")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu12267399306151291842.png width=300 height=293 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>米粒儿</a></h1><h2 class=site-description>命里八分，莫求一丈</h2></div></header><ol class=menu-social><li><a href=https://github.com/Tuanzi-bug target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#mysql-基础架构>MySQL 基础架构</a><ol><li><a href=#1-查询语句在mysql-的执行过程>1. 查询语句在Mysql 的执行过程</a></li><li><a href=#2-更新语句在mysql-的执行过程>2. 更新语句在Mysql 的执行过程</a></li><li><a href=#5-什么是数据页的空洞如何解决>5. 什么是数据页的空洞，如何解决？</a></li><li><a href=#6-在-select-count-from-t-这样的查询语句里面countcount主键-idcount字段-和-count1-等不同用法的性能有哪些差别>6. 在 select count(?) from t 这样的查询语句里面，count(*)、count(主键 id)、count(字段) 和 count(1) 等不同用法的性能，有哪些差别。</a></li><li><a href=#7order-by-中是如何排序的吗>7.order by 中是如何排序的吗？</a></li><li><a href=#8-全字段排序有什么性能限制吗>8. 全字段排序有什么性能限制吗？</a></li><li><a href=#9-如何优化全字段排序带来的性能限制>9. 如何优化全字段排序带来的性能限制？</a></li><li><a href=#10-rowid-排序是如何执行的>10. rowid 排序是如何执行的？</a></li><li><a href=#11目前你返回的数据行数较多如果返回行数较少那么会使用什么排序>11.目前你返回的数据行数较多，如果返回行数较少，那么会使用什么排序？</a></li><li><a href=#12-order-by-rand-是如何执行的>12. order by rand() 是如何执行的？</a></li><li><a href=#其他问题>其他问题</a></li></ol></li><li><a href=#数据库事务>数据库事务</a><ol><li><a href=#1-介绍事务的特性>1. 介绍事务的特性</a></li><li><a href=#2-并发事务带来的问题>2. 并发事务带来的问题</a></li><li><a href=#3-不同事务隔离级别的区别>3. 不同事务隔离级别的区别</a></li><li><a href=#4-事务隔离的可见性实现>4. 事务隔离的可见性实现</a></li><li><a href=#5-长事务的弊病>5. 长事务的弊病</a></li><li><a href=#6-mvcc是什么>6. MVCC是什么</a></li><li><a href=#7mvvc中的快照是如何实现的>7.MVVC中的快照是如何实现的</a></li><li><a href=#8-一致性读和当前读是什么>8. 一致性读和当前读是什么</a></li><li><a href=#9幻读的定义以及幻读有什么问题>9.幻读的定义以及幻读有什么问题？</a></li><li><a href=#10如何解决幻读>10.如何解决幻读</a></li><li><a href=#其他问题-1>其他问题</a></li><li><a href=#参考文献>参考文献：</a></li></ol></li><li><a href=#索引>索引</a><ol><li><a href=#1-哈希表有序数组和搜索树的优缺点>1. 哈希表、有序数组和搜索树的优缺点</a></li><li><a href=#2主键索引和普通索引是什么在查询中的区别是什么>2.主键索引和普通索引是什么，在查询中的区别是什么</a></li><li><a href=#3-主键不是有序的会带来什么问题自增主键有什么优势有没有什么场景适合用业务字段直接做主键的呢>3. 主键不是有序的会带来什么问题，自增主键有什么优势，有没有什么场景适合用业务字段直接做主键的呢？</a></li><li><a href=#4-一条sql查询语句会扫描多少行以及几次树的搜索操作>4. 一条Sql查询语句，会扫描多少行以及几次树的搜索操作</a></li><li><a href=#5-说一下覆盖索引和联合索引>5. 说一下覆盖索引和联合索引</a></li><li><a href=#6-最左前缀原则详细介绍>6. 最左前缀原则详细介绍</a></li><li><a href=#7-如何安排索引内的字段顺序>7. 如何安排索引内的字段顺序</a></li><li><a href=#8-索引下推详细介绍>8. 索引下推详细介绍</a></li><li><a href=#9-普通索引和唯一索引在查询和更新有什么区别>9. 普通索引和唯一索引在查询和更新有什么区别</a></li><li><a href=#10-change-buffer-是什么>10. change Buffer 是什么？</a></li><li><a href=#11-change-buffer-和-redo-log-都是减少随机读写那么之间区别是什么>11. change buffer 和 redo log 都是减少随机读写，那么之间区别是什么</a></li><li><a href=#12-当机器掉电重启会不会导致-change-buffer-丢失呢会不会发生数据丢失情况>12. 当机器掉电重启，会不会导致 change buffer 丢失呢，会不会发生数据丢失情况？</a></li><li><a href=#13-前缀索引优缺点>13. 前缀索引优缺点</a></li></ol></li><li><a href=#锁>锁</a><ol><li><a href=#全局锁是什么在哪些场景下使用>全局锁是什么，在哪些场景下使用。</a></li><li><a href=#表级别的锁有哪些>表级别的锁有哪些？</a></li><li><a href=#元数据锁在什么情况下会发生阻塞>元数据锁在什么情况下会发生阻塞？</a></li><li><a href=#意向锁是什么干什么用的>意向锁是什么，干什么用的？</a></li><li><a href=#行锁是什么有哪些>行锁是什么，有哪些，</a></li><li><a href=#两阶段协议是什么>两阶段协议是什么？</a></li><li><a href=#select-for-update--update-等具有加锁性质的语句加锁有什么需要注意的>select for update / update 等具有加锁性质的语句加锁有什么需要注意的</a></li><li><a href=#如何避免执行加锁性质的语句锁住全表事故的发生>如何避免执行加锁性质的语句锁住全表事故的发生？</a></li><li><a href=#5死锁是什么如何解决>5.死锁是什么，如何解决？</a></li><li><a href=#6怎么解决由这种热点行更新导致的性能问题呢>6.怎么解决由这种热点行更新导致的性能问题呢？</a></li><li><a href=#9-加锁的原则>9. 加锁的原则</a></li></ol></li><li><a href=#内存>内存</a></li><li><a href=#高可用>高可用</a><ol><li><a href=#mysql主备的基本流程>Mysql主备的基本流程</a></li><li><a href=#对于主备库为双m结构互为主备关系会发生什么问题怎么解决>对于主备库为双M结构，互为主备关系，会发生什么问题？怎么解决？</a></li><li><a href=#主备延迟的原因>主备延迟的原因</a></li></ol></li><li><a href=#日志篇>日志篇</a><ol><li><a href=#redolog>redolog</a><ol><li><a href=#为什么需要-redo-log>为什么需要 <code>redo log</code></a></li><li><a href=#什么是-redo-log>什么是 <code>redo log</code></a></li></ol></li><li><a href=#binlog>binlog</a></li><li><a href=#undolog>undolog</a></li><li><a href=#两阶段提交日志具体流程>两阶段提交日志具体流程</a></li><li><a href=#为什么是两阶段提交日志>为什么是两阶段提交日志</a></li><li><a href=#两阶段提交日志存在什么问题>两阶段提交日志存在什么问题？</a></li><li><a href=#什么时候怎么刷盘binlog>什么时候，怎么刷盘binlog</a></li><li><a href=#什么时候怎么刷盘redo-log>什么时候，怎么刷盘redo log</a></li><li><a href=#binlog的三种格式之间的对比>binlog的三种格式之间的对比。</a></li><li><a href=#在两阶段提交日志有什么方法可以降低磁盘io>在两阶段提交日志，有什么方法可以降低磁盘IO？</a></li><li><a href=#如果你的-mysql-现在出现了性能瓶颈而且瓶颈在-io-上可以通过哪些方法来提升性能呢>如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？</a></li></ol></li><li><a href=#场景题>场景题</a><ol><li><a href=#1-在什么情况下会出现查一行数据会执行得特别慢的现象>1. 在什么情况下会出现查一行数据会执行得特别慢的现象？</a></li><li><a href=#2-业务高峰期生产环境的-mysql-压力太大没法正常响应有哪些方案可以短期内临时性地提升一些性能>2. 业务高峰期，生产环境的 MySQL 压力太大，没法正常响应，有哪些方案可以短期内、临时性地提升一些性能。</a></li><li><a href=#3-全表扫描server层的流程>3. 全表扫描，server层的流程</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/database/>Database</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/mysql/>Mysql-八股题</a></h2><h3 class=article-subtitle>mysql-八股题，包含：基础、锁、索引、事务以及场景题</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Nov 30, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 10 分钟</time></div></footer></div></header><section class=article-content><h2 id=mysql-基础架构>MySQL 基础架构</h2><img src=./assets/mysql架构图.png alt=架构图 style=zoom:33%><blockquote><p>其实图相对重要一些，一些相关题目可以记忆这个图进行回答</p></blockquote><p>Mysql分为Server层和存储引擎层两部分。</p><ul><li><strong>连接器：</strong> 身份认证和权限相关</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存(命中概率低，8.0移除)</li><li><strong>分析器：</strong> 进行词法分析和语法分析，检查是否正确以及进行鉴权</li><li><strong>优化器：</strong> 决定选择使用最优方案，例如匹配索引，多表关联(join)的连接顺序</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 （会对实际运行的表进行鉴权）</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><h3 id=1-查询语句在mysql-的执行过程>1. 查询语句在Mysql 的执行过程</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>tb_student</span><span class=w>  </span><span class=n>A</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>age</span><span class=o>=</span><span class=s1>&#39;18&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>name</span><span class=o>=</span><span class=s1>&#39; 张三 &#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol><li>连接数据库</li><li>在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果。（在工程实现中，在查询缓存返回结果之前，做权限校验）。</li><li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=&lsquo;1&rsquo;。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。（注：在词法分析阶段，会进行 precheck 验证权限，判断是否有权限。）</li><li>优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</li><li>在执行器过程，会先进行权限校验，然后会调用数据库引擎接口，返回引擎的执行结果。</li></ol><h3 id=2-更新语句在mysql-的执行过程>2. 更新语句在Mysql 的执行过程</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>update</span><span class=w> </span><span class=n>tb_student</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>age</span><span class=o>=</span><span class=s1>&#39;19&#39;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>name</span><span class=o>=</span><span class=s1>&#39; 张三 &#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>更新语句会沿着查询的流程走，与查询语句不同的是执行更新时候，会记录日志。</p><ol><li>执行器会找到目标行数据。如果目标行所在的数据页在内存（Buffer Pool ）中，就会直接返回执行器，否则需要从磁盘读入内存，再返回。</li><li>执行器拿到引擎给的行数据，修改对应字段值，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><img src=./assets/update语句执行流程.png alt=update语句执行流程 style=zoom:25%><h3 id=5-什么是数据页的空洞如何解决>5. 什么是数据页的空洞，如何解决？</h3><p>在InnoDB引擎中，删除某一行数据，会把这个一行数据标记为删除，表明可以复用。行数据的复用，只限于符合范围条件的数据。当你随机删除过多，会造成一个数据页中存在很多可以复用但是没有被使用的地方，称之为空洞。</p><p>不止是删除数据会造成空洞，插入数据也会。</p><p>当把一个数据页上的所有数据都删除，表明数据页也可以被复用，但是表空间不会回收。</p><p>解决方案：使用Online DDL方式重建表</p><p>重建表的流程：</p><ul><li>建立一个临时文件，扫描表 A 主键的所有数据页；</li><li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件；</li><li>用临时文件替换表 A 的数据文件。</li></ul><h3 id=6-在-select-count-from-t-这样的查询语句里面countcount主键-idcount字段-和-count1-等不同用法的性能有哪些差别>6. 在 select count(?) from t 这样的查询语句里面，count(*)、count(主键 id)、count(字段) 和 count(1) 等不同用法的性能，有哪些差别。</h3><ul><li>count(主键 id) ：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，往count函数放一个数字“1”进去，判断是不可能为空的，按行累加。</li><li>count(字段) ：【如果没有索引，走主键索引】<ul><li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li><li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li></ul></li><li>count(*)：不需要取值，按行累加。【可能走最小的索引】</li></ul><p>按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1) ≈ count(*)</p><h3 id=7order-by-中是如何排序的吗>7.order by 中是如何排序的吗？</h3><p>有这样一个sql语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>city</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>age</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>city</span><span class=o>=</span><span class=s1>&#39;杭州&#39;</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>1000</span><span class=w>  </span><span class=p>;</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=n>city是索引</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个语句执行流程如下所示 ：</p><ul><li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li><li>从索引 city 找到第一个满足 city=&lsquo;杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；按照排序结果取前 1000 行返回给客户端。、</li></ul><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。</p><p>也称之为全字段排序（把所需字段全放入 sort_buffer中）。</p><p><mark>对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。</mark></p><h3 id=8-全字段排序有什么性能限制吗>8. 全字段排序有什么性能限制吗？</h3><p>排序，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。</p><p>排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则需要利用磁盘临时文件辅助排序。</p><p>外部排序一般使用多路归并排序算法。</p><p>如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><h3 id=9-如何优化全字段排序带来的性能限制>9. 如何优化全字段排序带来的性能限制？</h3><ul><li><p>增大 <code>sort_buffer_size</code>：尽量提高内存中的排序缓冲区大小，使得内存能够容纳更多的行，减少生成临时文件的数量。</p></li><li><p>减少查询中返回的字段数量：查询时只返回必要的字段（使用 <code>SELECT</code> 时避免 <code>SELECT *</code>），减少单行数据占用的空间，从而让内存能够存储更多行。</p></li><li><p>构建联合\覆盖索引：让结果是有序的，减少排序过程。</p></li><li><p>让Mysql 采用另一种排序方法：rowId 排序。</p></li></ul><h3 id=10-rowid-排序是如何执行的>10. rowid 排序是如何执行的？</h3><p>max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p><p>整个执行流程：</p><ul><li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li><li>从索引 city 找到第一个满足 city=&lsquo;杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=&lsquo;杭州’条件为止，也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 进行排序；遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li></ul><p>与全字段排序的区别：</p><ul><li>sort_buffer 只放入和排序相关的字段</li><li>多了一次回表的过程，一般优化器会选择全字段排序。</li></ul><p><mark>如果 MySQL 认为排序内存太小，会采用 rowid 排序算法，如果 MySQL 认为内存足够大，会优先选择全字段排序。</mark></p><h3 id=11目前你返回的数据行数较多如果返回行数较少那么会使用什么排序>11.目前你返回的数据行数较多，如果返回行数较少，那么会使用什么排序？</h3><p>在 MySQL 中，排序会优先尝试使用内存：</p><ul><li>当需要排序的数据量小于 <code>sort_buffer_size</code> 时，MySQL 会将数据加载到内存中并直接进行排序（通常使用快速排序）；</li><li>如果数据量大于 <code>sort_buffer_size</code>，MySQL 会将数据分批加载到内存中，执行部分排序后写入临时文件，最后通过外部归并排序完成整体排序。</li><li>如果单行大于<code>max_length_for_sort_data</code>,Mysql将会使用rowid的排序。</li><li>对于 <code>ORDER BY ... LIMIT N</code> 的场景，MySQL 可能使用堆排序（优先队列）来优化性能，动态维护前 N 条记录，从而避免完全排序。</li><li>临时文件的使用则是基于内存不足时存储中间结果的需要。</li></ul><h3 id=12-order-by-rand-是如何执行的>12. order by rand() 是如何执行的？</h3><ol><li><strong>读取数据集</strong>：MySQL 从存储引擎中读取目标表中的所有符合条件的行（如果没有 <code>WHERE</code> 条件，则读取整个表）。</li><li><strong>生成随机值</strong>：对于每一行，调用 <code>RAND()</code> 函数生成一个随机值，并将随机值与该行的数据关联存储在内存或临时表中。</li><li><strong>排序</strong>：使用内存中的随机值作为排序键，对数据进行排序。如果数据量过大而无法全部放入内存，则使用磁盘上的临时文件进行外部排序。</li><li><strong>返回结果</strong>：根据排序后的数据返回结果。如果指定了 <code>LIMIT</code>，则只返回前 N 条数据；否则返回排序后的所有行。</li></ol><p>注意事项：</p><ul><li><code>ORDER BY RAND()</code> 对所有行生成随机数并排序，导致 CPU 和内存消耗较大。当表很大时，会严重影响性能。</li></ul><p>优化建议：</p><ul><li>预先选取随机主键范围（如 <code>WHERE id >= FLOOR(RAND() * max_id)</code>）结合 <code>LIMIT</code>。</li><li>使用应用层随机化，而非在 SQL 层执行。</li></ul><ul><li></li></ul><h3 id=其他问题>其他问题</h3><ul><li>两个日志的区别</li><li>两阶段执行过程</li></ul><h2 id=数据库事务>数据库事务</h2><h3 id=1-介绍事务的特性>1. 介绍事务的特性</h3><p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。简单说：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><p>具有ACID特性：</p><ul><li><p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p></li><li><p><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><p>注意：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h3 id=2-并发事务带来的问题>2. 并发事务带来的问题</h3><ul><li>脏读（Dirty read）：读取到其他事务未提交的数据。</li><li>丢失修改（Lost to modify）：指两个或多个事务同时对同一数据进行更新操作，其中一个事务的更新被另一个事务覆盖，导致前一个事务的修改丢失。</li><li>不可重复读（Unrepeatable read）：在一个事务中，前后读取的记录内容不一致；</li><li>幻读（Phantom read）：在一个事务中，前后读取的记录数量不一致。</li></ul><h3 id=3-不同事务隔离级别的区别>3. 不同事务隔离级别的区别</h3><ul><li><p><strong>READ-UNCOMMITTED(读取未提交)</strong> ：可以读取尚未提交的数据变更。</p></li><li><p><strong>READ-COMMITTED(读取已提交)</strong> ：可以读取其他并发事务已经提交的数据。</p></li><li><p><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的。</p></li><li><p><strong>SERIALIZABLE(可串行化)</strong> ：加读写锁，保证所有的事务依次逐个执行。</p></li></ul><p>在不同隔离级别下可能发生的问题：</p><div class=table-wrapper><table><thead><tr><th style=text-align:center>隔离级别</th><th style=text-align:center>脏读</th><th style=text-align:center>不可重复读</th><th style=text-align:center>幻读</th></tr></thead><tbody><tr><td style=text-align:center>读未提交</td><td style=text-align:center>√</td><td style=text-align:center>√</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>读提交</td><td style=text-align:center>×</td><td style=text-align:center>√</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>可重复读</td><td style=text-align:center>×</td><td style=text-align:center>×</td><td style=text-align:center>√</td></tr><tr><td style=text-align:center>串行化</td><td style=text-align:center>×</td><td style=text-align:center>×</td><td style=text-align:center>×</td></tr></tbody></table></div><h3 id=4-事务隔离的可见性实现>4. 事务隔离的可见性实现</h3><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><ul><li>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li><li>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</li><li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</li><li>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li></ul><h3 id=5-长事务的弊病>5. 长事务的弊病</h3><p>长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</p><h3 id=6-mvcc是什么>6. MVCC是什么</h3><p>MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。</p><p>读操作：当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。</p><p>写操作：当一个事务执行写操作时，它会生成一个新的数据版本，事务提交后将修改后的数据写入数据库。</p><p>为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</p><h3 id=7mvvc中的快照是如何实现的>7.MVVC中的快照是如何实现的</h3><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p><p>数据表中的一行记录，有多个版本 (row)，每个版本有自己的 row trx_id，是transaction id进行赋值的。</p><img src=./assets/行状态变更.png alt=img style=zoom:50%><p>当一个事务修改表中数据的某一行时，将旧版本的数据插入 Undo Log 中，看到的视图不是物理上物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 视图的时候，就是通过 V4 依次执行 U3、U2 算出来。根据 row trx_id、undo log这些信息，实现了数据行的多版本效果。</p><p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>（即 m_ids）。</p><p>Read View 存在两个变量：</p><ul><li>m_up_limit_id：数组里面事务 ID 的最小值</li><li>m_low_limit_id ：当前系统里面已经创建过的事务 ID 的最大值</li></ul><p>当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>row TRX_ID</code> 与 <code>Read View</code> 中的这两个变量 进行比较，判断是否满足可见性条件，不满足就回滚。</p><img src=./assets/trans_visible.jpg alt=trans_visible style=zoom:50%><p>一个数据版本的 row trx_id，有以下几种可能：</p><ul><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<ul><li>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li><li>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ul></li></ul><p>核心简写：</p><ul><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ul><p>总结：</p><ul><li>row trx_id 和 transaction id 给每个数据行提供版本号</li><li>undo log 提供版本链，帮助回滚到需要的数据</li><li>该记录行的 <code>row TRX_ID</code> 与 <code>Read View</code> 中的这两个变量 m_up_limit_id 和 m_low_limit_id 进行比较，判断是否满足可见性条件，不满足就回滚。</li></ul><h3 id=8-一致性读和当前读是什么>8. 一致性读和当前读是什么</h3><p>一致性读是指事务在开启视图时候，直至提交之前，读行数据始终保持一致。主要用到<strong>MVCC（多版本并发控制）</strong> 技术，在事务中，查询语句不会看到其他事务未提交以及以后事务的更改。</p><p>当前读是指读取行数据的最新版本，通过给行数据加Next-key Lock锁来保证的。如果当前的行数据的Next-key Lock锁被其他事务占用的话，就需要进入锁等待。在事务中执行<strong>select&mldr;for update/lock in share mode、insert、update、delete</strong> 等都是当前读。</p><h3 id=9幻读的定义以及幻读有什么问题>9.幻读的定义以及幻读有什么问题？</h3><p>幻读是当一个事务在执行某个范围查询时，比如使用<code>SELECT ... WHERE</code>语句，第一次查询返回了一些满足条件的行，但在事务继续执行的过程中，另一个事务插入了一些新的符合查询条件的行，导致第二次相同的查询返回的结果集比第一次更多。</p><p>关键点在于插入，导致的结果集的不同。</p><p>其实会导致数据不一致的问题，实际上，binlog的结果和实际表不一致。一致性指的是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p><h3 id=10如何解决幻读>10.如何解决幻读</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。</p><ul><li>在可重复读隔离级别，引入<code>Next-key Lock（Record Lock+Gap Lock）</code></li><li>在读提交隔离级别，需要把 binlog 格式设置为 row，解决可能出现的数据和日志不一致问题，</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li></ul><h3 id=其他问题-1>其他问题</h3><h3 id=参考文献>参考文献：</h3><ul><li><a class=link href=https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1 target=_blank rel=noopener>https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1</a></li><li></li></ul><h2 id=索引>索引</h2><h3 id=1-哈希表有序数组和搜索树的优缺点>1. 哈希表、有序数组和搜索树的优缺点</h3><ul><li>哈希表是一种以键值对存储数据的结构。适用于等值查询的场景，例如NoSQL引擎，区间查询的速度很慢。</li><li>有序数组在等值查询和范围查询的场景中性能优秀，但是在更新数据上，成本太高，只适用于静态存储引擎。</li><li>搜索树的特点是父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。二叉树树高过高，访问多个数据块，磁盘随机读取数据块过于耗时，会采用N叉树。N取决于数据块的大小。以InnoDB 的一个整数字段索引为例，在一个节点（页）中，这个 N 差不多是 1200。</li></ul><h3 id=2主键索引和普通索引是什么在查询中的区别是什么>2.主键索引和普通索引是什么，在查询中的区别是什么</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，每一个索引在 InnoDB 里面对应一棵 B+ 树。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p><p>在查询过程中，基于非主键索引的查询需要回表（到主键索引树在搜索一次），相比之下多扫描一颗索引树。</p><img src=assets/innodb的索引组织结构.png alt=img style=zoom:33%><h3 id=3-主键不是有序的会带来什么问题自增主键有什么优势有没有什么场景适合用业务字段直接做主键的呢>3. 主键不是有序的会带来什么问题，自增主键有什么优势，有没有什么场景适合用业务字段直接做主键的呢？</h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。当页满了，根据 B+ 树的算法，需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂。页分裂操作会影响性能也会影响数据页的利用率。</p><ul><li>性能角度：自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</li><li>存储空间：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li></ul><p>在场景是<mark>只有一个索引；该索引必须是唯一索引</mark>（KV场景），适合用业务字段直接做主键。</p><h3 id=4-一条sql查询语句会扫描多少行以及几次树的搜索操作>4. 一条Sql查询语句，会扫描多少行以及几次树的搜索操作</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>表：主键</span><span class=n>ID索引</span><span class=err>，</span><span class=n>k索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>+</span><span class=c1>-----+---+----+
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span><span class=w> </span><span class=n>ID</span><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>s</span><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>+</span><span class=c1>-----+---+----+
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>aa</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>|</span><span class=w> </span><span class=mi>200</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>bb</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>|</span><span class=w> </span><span class=mi>300</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>cc</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>|</span><span class=w> </span><span class=mi>500</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>ee</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>|</span><span class=w> </span><span class=mi>600</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>6</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>ff</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>|</span><span class=w> </span><span class=mi>700</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>7</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>gg</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>+</span><span class=c1>-----+---+----+
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>#</span><span class=w> </span><span class=err>执行语句：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=k>between</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=mi>5</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><img src=assets/innodb的索引组织结构.png alt=img style=zoom:33%><p>这条 SQL 查询语句的执行流程：</p><ul><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li></ul><h3 id=5-说一下覆盖索引和联合索引>5. 说一下覆盖索引和联合索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，（核心是无需回表查询），就称之为 <strong>覆盖索引（Covering Index）</strong> 。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能。</p><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>。</p><h3 id=6-最左前缀原则详细介绍>6. 最左前缀原则详细介绍</h3><p>最左前缀匹配原则指的是在使用索引时候，查询条件满足左前缀条件，可以利用索引加速检索。最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>对于一个联合索引 <code>(A, B, C)</code>：</p><ul><li>索引能被以下查询利用：<ul><li><code>WHERE A = ?</code></li><li><code>WHERE A = ? AND B = ?</code></li><li><code>WHERE A = ? AND B = ? AND C = ?</code></li></ul></li></ul><p>最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、&lt;）为止。对于 >=、&lt;=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配。</p><h3 id=7-如何安排索引内的字段顺序>7. 如何安排索引内的字段顺序</h3><ul><li><p>如果通过调整顺序，可以帮助少维护一个索引。</p></li><li><p>可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p></li><li><p>考虑空间。</p></li></ul><h3 id=8-索引下推详细介绍>8. 索引下推详细介绍</h3><p>索引下推优化（index condition pushdown)是指在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，提高查询效率。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>zipcode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;431200&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=k>MONTH</span><span class=p>(</span><span class=n>birthdate</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>3</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=/p/mysql/assets/index-condition-pushdown-graphic-illustration.png width=718 height=541 srcset="/p/mysql/assets/index-condition-pushdown-graphic-illustration_hu7612177516252582024.png 480w, /p/mysql/assets/index-condition-pushdown-graphic-illustration_hu15908210992178577081.png 1024w" loading=lazy alt=img class=gallery-image data-flex-grow=132 data-flex-basis=318px></p><h3 id=9-普通索引和唯一索引在查询和更新有什么区别>9. 普通索引和唯一索引在查询和更新有什么区别</h3><p>在查询过程中：</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>查询带来的性能差距是微乎其微。</p><p>在更新过程中：</p><p>第一种情况是，这个记录要更新的目标页在内存中。</p><ul><li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><p>在该情况下，性能差别很小。</p><p>第二种情况是，这个记录要更新的目标页不在内存中。</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>因为将数据从磁盘读入内存涉及随机 IO 的访问，是成本比较高的操作，对于唯一索引就需要不断地将数据页读入内存，然后change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><h3 id=10-change-buffer-是什么>10. change Buffer 是什么？</h3><p>当某个行数据所在的数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了，后续会将里面操作应用在原数据页中。</p><p>当访问这个数据页（将数据页读入内存中）会触发 merge 操作，在写多读少的业务场景中，在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），使用效果越好。但是在写入之后马上会做查询场景中，会触发change buffer的merge 过程，增加了 change buffer 的维护代价。</p><h3 id=11-change-buffer-和-redo-log-都是减少随机读写那么之间区别是什么>11. change buffer 和 redo log 都是减少随机读写，那么之间区别是什么</h3><ul><li><p>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）（将内存的数据写入磁盘中）</p></li><li><p>change buffer 主要节省的则是随机读磁盘的 IO 消耗。（主要是将更新动作变缓，减少读入数据页的过程，）</p></li></ul><h3 id=12-当机器掉电重启会不会导致-change-buffer-丢失呢会不会发生数据丢失情况>12. 当机器掉电重启，会不会导致 change buffer 丢失呢，会不会发生数据丢失情况？</h3><p>不会丢失。</p><ul><li><p>Change Buffer 的内容不仅仅在内存中也会持久化，同时Change Buffer 的修改操作（如插入、更新或删除）也会被记录到 <strong>Redo Log</strong> 中。</p></li><li><p>在数据库掉电恢复时会重放 Redo Log，恢复未完成的事务和未刷入磁盘的修改，包括 Change Buffer 的修改。如果 Change Buffer 中有未完成的合并操作，InnoDB 会通过后台线程继续执行这些合并，将修改逐步应用到目标数据页。</p></li></ul><h3 id=13-前缀索引优缺点>13. 前缀索引优缺点</h3><p>优点：</p><ul><li>使用前缀索引和字段区分度有很大的关系，区分度越高越好。</li><li>前缀索引可以对字符串的前缀构建索引，定义好前缀长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li></ul><p>缺点：</p><ul><li>使用前缀索引就用不上覆盖索引对查询性能的优化</li><li>前缀索引选取字段长度的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</li></ul><p>提高前缀索引搜索效率方式：</p><ul><li>对字符串字段进行处理使其区分度增加，例如倒叙、截断等；</li><li>使用hash字段；</li></ul><h2 id=锁>锁</h2><h3 id=全局锁是什么在哪些场景下使用>全局锁是什么，在哪些场景下使用。</h3><p>全局锁就是对整个数据库实例加锁。全局锁的典型使用场景是，做全库逻辑备份。</p><p>使用风险：</p><ul><li>如果在主库备份，在备份期间不能更新，业务停摆</li><li>如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟</li></ul><p>对于InnoDB引擎，可以通过在可重复读隔离级别下开启一个事务，获取数据，在这个过程中数据是可以正常更新的。</p><p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。（只适用于支持事务引擎）</p><h3 id=表级别的锁有哪些>表级别的锁有哪些？</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p>表锁会限制别的线程的读写外，也可能限定了本线程的读写操作，一般用的少，影响面太大了。</p><p>MDL主要用于隔离DML（Data Manipulation Language，数据操纵语言，如select）和DDL（Data Definition Language，数据定义语言，如改表头新增一列）操作之间的干扰，保证对表数据读写正确。</p><p>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><h3 id=元数据锁在什么情况下会发生阻塞>元数据锁在什么情况下会发生阻塞？</h3><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>如果长事务存在DDL操作，后面有很多DML操作发生阻塞，导致线程爆满。</p><p>为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑设置超时或者 kill 掉这个长事务，然后再做表结构的变更。</p><h3 id=意向锁是什么干什么用的>意向锁是什么，干什么用的？</h3><p>意向锁是一个表级锁，为了支持 InnoDB 的多粒度锁，它解决的是表锁和行锁共存的问题。</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p><p>当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。</p><p>假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；</p><p>有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。因为意向锁会和表锁互斥。</p><p>意向锁之间是互相兼容的。</p><div class=table-wrapper><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table></div><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><div class=table-wrapper><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table></div><h3 id=行锁是什么有哪些>行锁是什么，有哪些，</h3><p>行锁就是针对数据表中行数据的锁，主要有三种：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li><li>插入意向锁：表示了一种插入意图，即当多个不同的事务，同时往同一个索引的同一个间隙中插入数据的时候，它们互相之间无需等待，即不会阻塞。</li></ul><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><div class=table-wrapper><table><thead><tr><th style=text-align:left></th><th style=text-align:left>S 锁</th><th>X 锁</th></tr></thead><tbody><tr><td style=text-align:left>S 锁</td><td style=text-align:left>不冲突</td><td>冲突</td></tr><tr><td style=text-align:left>X 锁</td><td style=text-align:left>冲突</td><td>冲突</td></tr></tbody></table></div><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>共享锁</span><span class=w> </span><span class=err>可以在</span><span class=w> </span><span class=n>MySQL</span><span class=w> </span><span class=mi>5</span><span class=p>.</span><span class=mi>7</span><span class=w> </span><span class=err>和</span><span class=w> </span><span class=n>MySQL</span><span class=w> </span><span class=mi>8</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=err>中使用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>LOCK</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=k>SHARE</span><span class=w> </span><span class=k>MODE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>共享锁</span><span class=w> </span><span class=err>可以在</span><span class=w> </span><span class=n>MySQL</span><span class=w> </span><span class=mi>8</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=err>中使用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>SHARE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>排他锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Gap Lock：为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 。间隙锁锁住了两个值的间隙，不包括记录本身，防止进行插入操作。间隙锁之间都不存在冲突关系。</p><p>next-key lock：间隙锁+行锁，锁定一个范围，包含记录本身，是左开右闭的区间。</p><p>插入意向锁：如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。<strong>插入意向锁和间隙锁之间是冲突的</strong>。</p><h3 id=两阶段协议是什么>两阶段协议是什么？</h3><p>两阶段锁协议：在 InnoDB 事务中，行锁是在需要（更新/插入行数据）的时候才加上的，需要等到事务结束时才释放。</p><p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，以减少锁等待的时间，提高并发性能。</p><h3 id=select-for-update--update-等具有加锁性质的语句加锁有什么需要注意的>select for update / update 等具有加锁性质的语句加锁有什么需要注意的</h3><p>当我们执行 select for update / update 语句时，实际上是会对记录加锁带基本单位是 next-key 锁，加锁的位置准确的说，锁是加在索引上的而非行上。如果其他事务对持有锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p><p><strong>在 select for update / update 语句的查询条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong>。</p><p>核心在于：<strong>这条语句在执行过程种，优化器最终选择的是全表扫描，那么就会对全表的记录进行加锁。</strong></p><h3 id=如何避免执行加锁性质的语句锁住全表事故的发生>如何避免执行加锁性质的语句锁住全表事故的发生？</h3><p>当 sql_safe_updates 设置为 1 时。update 语句必须满足如下条件之一才能执行成功：</p><ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>使用 limit；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><p>delete 语句必须满足以下条件能执行成功：</p><ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul><h3 id=5死锁是什么如何解决>5.死锁是什么，如何解决？</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p>当出现死锁以后，有两种策略通过「打破循环等待条件」来解除：</p><ul><li>一种策略是，直接进入等待，直到超时。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。</li></ul><p>对于业务来说，第一种策略是不可取的，时间太短，会出现很多误伤，时间太长影响体验。</p><p>正常情况下采用第二种策略，能够快速发现并进行处理的，但是它也是有额外负担的。当较多线程更新同一行，死锁检测会消耗大量的 CPU 资源。</p><h3 id=6怎么解决由这种热点行更新导致的性能问题呢>6.怎么解决由这种热点行更新导致的性能问题呢？</h3><p>高并发下避免死锁检测带来的负面影响：</p><ol><li>确保业务上不会产生死锁，直接将死锁检测关闭。（innodb 自带死锁检测）</li><li>在数据库中间件中统一对更新同一行的请求进行排队，控制并发度。</li><li>业务逻辑上进行优化，将一行数据分解成多行，降低写入压力。</li></ol><h3 id=9-加锁的原则>9. 加锁的原则</h3><p>原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p><p>原则 2：查找过程中访问到的对象才会加锁。加锁是加在索引上的。</p><p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。（在唯一的，所以退化成行锁）</p><p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。（因为最后一个值不满足，所以可以不加锁）</p><blockquote><p>与锁相关的：06、07、20、21、30、39、40</p></blockquote><h2 id=内存>内存</h2><h2 id=高可用>高可用</h2><h3 id=mysql主备的基本流程>Mysql主备的基本流程</h3><img src=./assets/主备一致.webp alt=主备流程 style=zoom:50%><p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。</p><p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p><ul><li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li><li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li><li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li><li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li><li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li></ul><h3 id=对于主备库为双m结构互为主备关系会发生什么问题怎么解决>对于主备库为双M结构，互为主备关系，会发生什么问题？怎么解决？</h3><p>会发生循环复制的问题。</p><p>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。</p><p>解决方案：</p><ul><li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ul><h3 id=主备延迟的原因>主备延迟的原因</h3><ul><li>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。<ul><li>解决方案：主备库选用相同规格的机器，并且做对称部署，</li></ul></li><li>备库的压力大。<ul><li>解决方案：一主多从。</li></ul></li><li>大事务</li><li>备库的并行复制能力。</li></ul><h2 id=日志篇>日志篇</h2><h3 id=redolog>redolog</h3><h4 id=为什么需要-redo-log>为什么需要 <code>redo log</code></h4><p><code>redo log</code> 是为了保证数据库的 <strong><code>crash-safe</code> 能力</strong>。
当数据库发生异常（如宕机或掉电）时，<code>redo log</code> 能够帮助恢复已提交但尚未完全持久化到数据文件的事务，确保数据一致性并减少数据丢失。</p><hr><h4 id=什么是-redo-log>什么是 <code>redo log</code></h4><p><code>redo log</code> 是 <strong>InnoDB 存储引擎实现的物理日志</strong>，用于记录对数据页的修改操作。它的关键特性包括：</p><ol><li><p><strong>记录内容</strong>：
记录某个表空间中某数据页特定位置的修改，例如对表空间 <code>XXX</code> 中数据页 <code>YYY</code> 偏移量 <code>ZZZ</code> 的更新 <code>AAA</code>。</p></li><li><p><strong>固定大小，循环写入</strong>：
默认大小为 4 GB，由多个日志文件组成，循环写入。</p><ul><li><strong><code>write pos</code>（写指针）</strong>：记录当前写入的位置，随着写入不断推进，循环至日志文件的开头。</li><li><strong><code>checkpoint</code>（检查点指针）</strong>：记录当前可以被擦除的位置。在擦除之前，日志内容必须已应用到数据文件中。</li></ul><p>优点：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul></li></ol><h3 id=binlog>binlog</h3><ul><li><p>是server层实现，是逻辑日志，记录的是语句的原始逻辑。比如“给 ID=2 这一行的 c 字段加 1 ”</p></li><li><p>是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ul><p>主要用于备份恢复，主从恢复，增量备份。</p><ol><li><strong>数据恢复</strong>：在数据库发生故障时，通过 binlog 可以进行数据的恢复。</li><li><strong>主从复制</strong>：在主从架构中，binlog 用于同步主库的操作到从库。</li><li><strong>增量备份</strong>：binlog 支持记录数据库的增量变化，便于在全量备份的基础上快速恢复最新数据。</li></ol><h3 id=undolog>undolog</h3><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。【可以理解成一种版本链】</p><p><strong>它保证了事务的 ACID 特性 (opens new window)中的原子性（Atomicity）</strong>。</p><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p><p>针对 delete 操作和 update 操作会有一些特殊的处理：</p><ul><li>delete操作实际上不会立即直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。</li><li>update分为两种情况：update的列是否是主键列。<ul><li>如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。</li><li>如果是主键列，update分两部执行：先删除该行，再插入一行目标行。</li></ul></li></ul><p><strong>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong>。</p><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录。</p><p>因此，undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><h3 id=两阶段提交日志具体流程>两阶段提交日志具体流程</h3><ol><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><h3 id=为什么是两阶段提交日志>为什么是两阶段提交日志</h3><p>核心目的：保证两份日志之间的逻辑一致（数据一致性）。</p><p>从反证法说明：</p><ul><li><p><strong>先写 redo log 直接提交，然后写 binlog</strong>：假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p></li><li><p><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p></li></ul><h3 id=两阶段提交日志存在什么问题>两阶段提交日志存在什么问题？</h3><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p><ul><li><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><h3 id=什么时候怎么刷盘binlog>什么时候，怎么刷盘binlog</h3><p>写入的机制：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。系统给 binlog cache 分配了一片内存，每个线程一个，如果超过了参数规定的大小，就要暂存到磁盘的page cache。</p><p>对于持久化也涉及到两步：</p><ul><li>write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘。</li><li>fsync，才是将数据持久化到磁盘的操作。</li></ul><p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p><ul><li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li><li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li><li>sync_binlog =N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li></ul><p>不同的设置会带来不同的结果：</p><ul><li><p>设置是 sync_binlog = 0，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p></li><li><p>sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p></li><li><p>sync_binlog 设置为 N的时候，需要能容少量事务的 binlog 日志丢失的风险。</p></li></ul><h3 id=什么时候怎么刷盘redo-log>什么时候，怎么刷盘redo log</h3><p>执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，会先写入到 redo log buffer，后续在持久化到磁盘。</p><p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p><ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到文件的page cache。</li></ul><p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p><p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p><h3 id=binlog的三种格式之间的对比>binlog的三种格式之间的对比。</h3><p>binlog 有三种格式，一种是 statement，一种是 row，第三种格式 mixed，是前两种格式的混合。</p><p>statement 格式中 binlog文件记录的是真实执行的语句。存在主备不一致的情况，例如在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 b。</p><p>row 格式的binlog记录的是真实数据行的字段的值，不存在主备不一致。</p><p>前两种格式各自的优缺点：</p><ul><li>因为 statement 格式的 binlog 可能会导致主备不一致，row 格式不会发生这个问题。</li><li>但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</li></ul><p>所以根据这些优缺点，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</p><ul><li></li></ul><h3 id=在两阶段提交日志有什么方法可以降低磁盘io>在两阶段提交日志，有什么方法可以降低磁盘IO？</h3><p>依赖于组提交（group commit）机制。</p><p>日志逻辑序列号（log sequence number，LSN） 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</p><p>有三组并发事务都要持久化磁盘，LSN都不一样，对应的 LSN 分别是 50、120 和 160。。过程如下：</p><ul><li>trx1 是第一个到达的，会被选为这组的 leader；</li><li>等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</li><li>trx1 去写盘的时候，带的就是 LSN=160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</li><li>这时候 trx2 和 trx3 就可以直接返回了。</li></ul><p>一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。</p><p>引入了组提交机制后，两阶段提交日志中的 prepare 阶段不变，对于binlog的wirte 阶段拆分为三个过程：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li></ul><p>上面的<strong>每个阶段都有一个队列</strong>，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><blockquote><p>为了提高redolog组提交性能，在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段之后。（在两个阶段之间）通过延迟写 redo log 的方式，为 redolog 做了一次组写入。</p></blockquote><p>如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：</p><ul><li><code>binlog_group_commit_sync_delay= N</code>，表示在等待 N 微妙后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「 binlog 文件」持久化到磁盘。</li><li><code>binlog_group_commit_sync_no_delay_count = N</code>，表示如果队列中的事务数达到 N 个，就忽视binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。</li></ul><h3 id=如果你的-mysql-现在出现了性能瓶颈而且瓶颈在-io-上可以通过哪些方法来提升性能呢>如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？</h3><ul><li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</li><li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</li></ul><h2 id=场景题>场景题</h2><h3 id=1-在什么情况下会出现查一行数据会执行得特别慢的现象>1. 在什么情况下会出现查一行数据会执行得特别慢的现象？</h3><p>等锁</p><ul><li>等表级锁，例如MDL写锁</li><li>等flush表</li><li>等行锁</li></ul><p>查询慢</p><ul><li>没有走索引，全表扫描</li><li>回滚日志过大引起的一致性读慢</li></ul><h3 id=2-业务高峰期生产环境的-mysql-压力太大没法正常响应有哪些方案可以短期内临时性地提升一些性能>2. 业务高峰期，生产环境的 MySQL 压力太大，没法正常响应，有哪些方案可以短期内、临时性地提升一些性能。</h3><p>第一种情况：短连接风暴</p><p>当处于业务高峰期时候，MySQL 建立连接的过程，除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限，成本较高</p><p>解决方案：</p><ul><li>第一种方法：先处理掉那些占着连接但是不工作的线程。<ul><li>可以设置wait_timeout参数，将一个线程空闲 wait_timeout 这么多秒之后，就会被 MySQL 直接断开连接。</li><li>优先断开事务外的连接</li></ul></li><li>第二种方法：减少连接过程的消耗。让数据库跳过权限验证阶段。</li></ul><p>第二种情况：慢查询引起的性能问题</p><p>存在三种可能</p><ul><li>索引没有设计好；<ul><li>解决方案：在主从库上紧急添加索引</li></ul></li><li>SQL 语句没写好；（可能没有用索引等）<ul><li>解决方案：query_rewrite 功能，可以把输入的一种语句改写成另外一种模式。</li></ul></li><li>MySQL 选错了索引。<ul><li>解决方案：使用查询重写功能，给原来的语句加上 force index，</li></ul></li></ul><p>第三种情况：QPS 突增问题</p><p>采用虚拟化、白名单机制、业务账号分离等方法，然后相关服务停掉。</p><h3 id=3-全表扫描server层的流程>3. 全表扫描，server层的流程</h3><ul><li>获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。</li><li>重复获取行，直到 net_buffer 写满，调用网络接口发出去。</li><li>如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。</li><li>如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
<a href=/tags/mysql/>Mysql</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Jan 10, 2025 18:05 CST</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/redis/><div class=article-details><h2 class=article-title>Redis-八股题</h2></div></a></article></div></div></aside><script src=//unpkg.com/@waline/client@v2/dist/waline.js></script><link href=//unpkg.com/@waline/client@v2/dist/waline.css rel=stylesheet><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({avatar:"",dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],lang:"zh-CN",locale:{admin:"Admin",placeholder:"Leave a comment and get notified by email when someone replies."},placeholder:"在此输入评论...",requiredMeta:["name"],serverURL:"https://comments.yangdiy.cn/",visitor:""})</script><footer class=site-footer><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></section><section class=copyright>&copy;
2024 -
2025 米粒儿</section><section class=totalcount>发表了5篇文章 ·
总计3.54k字</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>let s1="2024-5-17";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script></body></html>