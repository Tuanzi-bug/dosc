## 基础架构篇



## 日志篇

### redolog

#### 为什么需要 `redo log`

`redo log` 是为了保证数据库的 **`crash-safe` 能力**。
当数据库发生异常（如宕机或掉电）时，`redo log` 能够帮助恢复已提交但尚未完全持久化到数据文件的事务，确保数据一致性并减少数据丢失。

------

####  什么是 `redo log`

`redo log` 是 **InnoDB 存储引擎实现的物理日志**，用于记录对数据页的修改操作。它的关键特性包括：

1. **记录内容**：
   记录某个表空间中某数据页特定位置的修改，例如对表空间 `XXX` 中数据页 `YYY` 偏移量 `ZZZ` 的更新 `AAA`。
2. **固定大小，循环写入**：
   默认大小为 4 GB，由多个日志文件组成，循环写入。
   - **`write pos`（写指针）**：记录当前写入的位置，随着写入不断推进，循环至日志文件的开头。
   - **`checkpoint`（检查点指针）**：记录当前可以被擦除的位置。在擦除之前，日志内容必须已应用到数据文件中。
3. **`crash-safe` 能力**：
   即使发生异常重启，`redo log` 仍可确保已提交事务的数据不会丢失。

------

####  什么时候刷盘

`redo log` 的写入并不是在事务操作中立即持久化到磁盘，而是经过以下步骤：

1. **写入 `redo log buffer`**：事务执行时，日志首先写入内存中的 `redo log buffer`。
2. 后台线程异步刷盘：InnoDB 的后台线程每隔 1 秒会将  redo log buffer 中的数据通过以下过程刷盘：
   - 调用 `write` 写入到文件系统的 `page cache`。
   - 再调用 `fsync` 将日志真正持久化到磁盘。

此外，通过参数 `innodb_flush_log_at_trx_commit` 可以控制事务提交时的刷盘行为：

- **`0`**：事务提交时，`redo log` 仅保留在 `redo log buffer`，不会触发写入磁盘。适合性能优先的场景，但存在数据丢失风险。
- **`1`**（默认）：事务提交时，`redo log` 会直接写入磁盘，确保 MySQL 异常重启后数据不丢失。
- **`2`**：事务提交时，`redo log` 写入到文件系统的 `page cache`，但未持久化到磁盘，性能与安全性折中。

---

### binlog

#### 什么是binlog

**binlog** 是 MySQL 中用于记录数据库修改操作的日志，是一种逻辑日志，记录的是事务或语句的逻辑操作，例如“将 ID=2 的记录的字段 c 加 1”。
它是 Server 层实现的，并且具有以下特点：

1. **追加写入**：binlog 是以追加方式写入的，日志文件达到一定大小后会切换到下一个文件，而不会覆盖旧日志。
2. **事务一致性**：一个事务的 binlog 是不可拆分的，必须一次性完整写入。

---

#### 为什么需要 binlog？

1. **数据恢复**：在数据库发生故障时，通过 binlog 可以进行数据的恢复。
2. **主从复制**：在主从架构中，binlog 用于同步主库的操作到从库。
3. **增量备份**：binlog 支持记录数据库的增量变化，便于在全量备份的基础上快速恢复最新数据。

---

#### binlog 的刷盘机制

事务执行过程中，日志会先写入 **binlog cache**。事务提交时，binlog cache 的内容会写入 binlog 文件，并涉及到两个关键步骤：

1. **write**：将日志写入文件系统的 page cache，但尚未持久化到磁盘。
2. **fsync**：将 page cache 中的数据持久化到磁盘。

MySQL 提供参数 **sync_binlog** 来控制 binlog 刷盘的频率：

- **sync_binlog = 0**：仅执行 write，不执行 fsync，交由操作系统决定何时持久化到磁盘。这种设置性能最佳，但风险最大，主机异常可能导致日志丢失。
- **sync_binlog = 1**：每次事务提交都会执行 write 和 fsync，是最安全的设置，但性能损耗较大。
- **sync_binlog = N (N > 1)**：每 N 个事务执行一次 fsync，性能与数据安全性在二者之间权衡。

---

#### binlog 的刷盘不同配置的影响

1. **sync_binlog = 0**：性能最佳，但风险最大。如果主机异常重启，未刷盘的 binlog 数据可能丢失。
2. **sync_binlog = 1**：最安全的设置，每次事务都进行 fsync，即使发生异常重启，最多丢失一个事务的数据。但这种方式对写入性能影响最大。
3. **sync_binlog = N (N > 1)**：性能和安全性之间的折中。允许少量事务的 binlog 丢失，以换取较高的写入性能。

---

